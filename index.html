<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>Agenda Diária 5.0 - Planejamento Moderno</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/_@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" href="favicon.ico" type="image/x-icon">
</head>

    <!-- <div class="max-w-5xl mx-auto bg-white rounded-lg shadow-lg p-6">  -->

    <style>
        /* Reset e estilos base */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #f8f7fa;
            color: #333;
            line-height: 1.6;
        }

        /* Cabeçalho */
        .app-header {
            background: linear-gradient(135deg, #8a4baf 0%, #6a3093 100%);
            color: white;
            padding: 0.5rem 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .app-title {
            text-align: center;
            font-size: 1.5rem;
            font-weight: 600;
            /* margin-bottom: 0.5rem; */ /* Removido para melhor alinhamento com o novo botão */
            flex-grow: 1; /* Faz o título ocupar espaço, ajudando a empurrar o botão para a direita */
        }

        .header-controls { /* Novo container para título e botão de configurações */
            display: flex;
            align-items: center;
            justify-content: space-between; /* Alinha título à esquerda e botões à direita */
            padding: 0 1rem; /* Adiciona padding horizontal se necessário */
            width: 100%;
        }

        .settings-btn {
            background: none;
            border: none;
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
            margin-left: auto; /* Empurra o botão para a direita se o título não preencher */
        }

        .settings-btn:hover {
            background-color: rgba(255, 255, 255, 0.15);
        }

        .settings-dropdown {
            position: absolute;
            top: 50px; /* Ajustar conforme necessário */
            right: 1rem;
            background-color: white;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 110;
            width: 200px;
            padding: 0.5rem 0;
        }

        .settings-dropdown button {
            display: block;
            width: 100%;
            padding: 0.75rem 1rem;
            text-align: left;
            background: none;
            border: none;
            color: #333;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .settings-dropdown button:hover {
            background-color: #f0f0f0;
        }

        .settings-dropdown hr {
            border: 0;
            height: 1px;
            background-color: #e0e0e0;
            margin: 0.5rem 0;
        }


        .date-nav {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
        }

        .date-display {
            font-size: 1.2rem;
            margin: 0 1rem;
            min-width: 200px;
            text-align: center;
        }

        .nav-btn {
            background-color: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .nav-btn:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }

        /* Navegação principal */
        .main-nav {
            display: flex;
            border-bottom: 1px solid #e0e0e0;
            background-color: white;
        }

        .nav-tab {
            flex: 1;
            text-align: center;
            padding: 1rem 0;
            cursor: pointer;
            transition: all 0.2s;
            color: #666;
            font-weight: 500;
        }

        .nav-tab.active {
            color: #6a3093;
            border-bottom: 3px solid #6a3093;
        }

        .nav-tab:hover:not(.active) {
            background-color: #f9f9f9;
        }

        /* Conteúdo principal */
        .content {
            padding: 1rem;
            max-width: 800px;
            margin: 0 auto;
            transition: max-width 0.3s ease-in-out; /* Para suavizar a transição */
        }

        body.week-horizontal-view-active .content {
            max-width: none; /* Permitir que o conteúdo se expanda */
        }

        /* Estilo das tarefas */
        .task-list {
            list-style: none;
        }

        .task-item {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            padding: 1rem;
            margin-bottom: 1rem;
            position: relative;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .task-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .task-header {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .task-time {
            background-color: #f0f0f0;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            margin-right: 0.5rem;
        }

        .task-title {
            font-weight: 600;
            flex: 1;
        }

        .task-description {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .task-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 0.5rem;
        }

        /* Prioridades */
        .priority-critical {
            border-left: 4px solid #e74c3c;
        }

        .priority-attention {
            border-left: 4px solid #f39c12;
        }

        .priority-normal {
            border-left: 4px solid #2ecc71;
        }

        /* Botões */
        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .btn-primary {
            background-color: #6a3093;
            color: white;
        }

        .btn-primary:hover {
            background-color: #8a4baf;
        }

        .btn-secondary {
            background-color: #f0f0f0;
            color: #333;
        }

        .btn-secondary:hover {
            background-color: #e0e0e0;
        }

        .btn-success {
            background-color: #2ecc71;
            color: white;
        }

        .btn-success:hover {
            background-color: #27ae60;
        }

        .btn-danger {
            background-color: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background-color: #c0392b;
        }

        .btn-sm {
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
        }

        .btn-icon {
            margin-right: 0.5rem;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            display: none;
        }

        .modal {
            background-color: white;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            padding: 1.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .modal-title {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        .form-control {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }

        .form-select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
            background-color: white;
        }

        .form-check {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .form-check-input {
            margin-right: 0.5rem;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            margin-top: 1rem;
        }

        .modal-footer .btn {
            margin-left: 0.5rem;
        }

        /* Estilo para o modal de confirmação genérico */
        #confirmationModal .modal-body {
            padding: 1rem 0;
            text-align: center;
            font-size: 1.1rem;
        }


        /* Comentários */
        .comments-section {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #eee;
        }

        .comment-list {
            list-style: none;
            margin-bottom: 1rem;
        }

        .comment-item {
            background-color: #f9f9f9;
            padding: 0.75rem;
            border-radius: 4px;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .comment-time {
            font-size: 0.8rem;
            color: #999;
        }

        .comment-image {
            max-width: 100%;
            border-radius: 4px;
            margin-top: 0.5rem;
        }

        .comment-form {
            display: flex;
            margin-top: 0.5rem;
        }

        .comment-input {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px 0 0 4px;
        }

        .comment-btn {
            border-radius: 0 4px 4px 0;
        }

        /* Badge */
        .badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .badge-primary {
            background-color: #6a3093;
            color: white;
        }

        .badge-success {
            background-color: #2ecc71;
            color: white;
        }

        .badge-warning {
            background-color: #f39c12;
            color: white;
        }

        .badge-danger {
            background-color: #e74c3c;
            color: white;
        }

        /* Visualização semanal */
        .week-view {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .week-day {
            background-color: white;
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .week-day-header {
            text-align: center;
            padding-bottom: 0.5rem;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid #eee;
        }

        .day-name {
            font-weight: 600;
            color: #6a3093;
        }

        .day-tasks {
            min-height: 100px;
        }

        .week-task {
            background-color: #f9f9f9;
            padding: 0.5rem;
            border-radius: 4px;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
            border-left: 3px solid #ddd;
        }

        .week-task.priority-critical {
            background-color: rgba(231, 76, 60, 0.1);
        }

        .week-task.priority-attention {
            background-color: rgba(243, 156, 18, 0.1);
        }

        .week-task.priority-normal {
            background-color: rgba(46, 204, 113, 0.1);
        }

        /* Estilos para Visualização Horizontal (Tabela) */
        .week-view-container.week-view-horizontal { /* Aplicar ao container */
            margin-left: calc(-50vw + 50%); /* Centraliza e permite expandir */
            margin-right: calc(-50vw + 50%);
            padding-left: 1rem; /* Adiciona padding para compensar a margem negativa em telas menores */
            padding-right: 1rem;
            max-width: none; /* Remove o max-width do pai .content */
            width: 100vw; /* Ocupa a largura da viewport */
            box-sizing: border-box;
        }
        .week-view-horizontal table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed; /* Para colunas de largura igual */
        }
        .week-view-horizontal th, .week-view-horizontal td {
            border: 1px solid #e0e0e0;
            padding: 0.5rem; /* Reduzido para mais espaço para conteúdo */
            text-align: left;
            vertical-align: top;
            font-size: 0.8rem; /* Reduzido para caber mais info */
        }
        .week-view-horizontal th { /* Cabeçalho dos horários e "Dia" */
            background-color: #f9f9f9;
            color: #6a3093;
            font-weight: 600;
            text-align: center;
        }
        .week-view-horizontal .horizontal-task-item {
            background-color: #f9f9f9;
            padding: 0.3rem 0.5rem;
            border-radius: 4px;
            margin-bottom: 0.3rem;
            font-size: 0.8rem;
            border-left: 3px solid #ccc; /* Cor padrão */
        }
        .week-view-horizontal .horizontal-task-item.priority-critical { border-left-color: #e74c3c; background-color: rgba(231, 76, 60, 0.05); }
        .week-view-horizontal .horizontal-task-item.priority-attention { border-left-color: #f39c12; background-color: rgba(243, 156, 18, 0.05); }
        .week-view-horizontal .horizontal-task-item.priority-normal { border-left-color: #2ecc71; background-color: rgba(46, 204, 113, 0.05); }
        .week-view-horizontal .task-time-horizontal {
            font-weight: bold;
            margin-right: 5px;
            display: block; /* Para que o título vá para a próxima linha se necessário */
            font-size: 0.75rem;
            color: #555;
        }
        .week-view-horizontal .task-title-horizontal {
            display: block;
        }
        .week-view-horizontal td.day-info-cell { /* Célula com nome do dia/data */
            width: 100px; /* Largura fixa para a coluna dos dias */
            min-width: 100px;
            text-align: center;
            font-weight: 500;
            background-color: #fdfdfd;
        }
        .week-view-horizontal td[colspan] { /* Célula container das tarefas do dia */
            padding: 0; /* Remover padding para que os blocos possam preencher */
            /* A altura pode ser definida para acomodar uma linha de blocos + um pouco de margem */
            /* Ex: Se o bloco tem 28px + 2px de top + 2px de bottom margin = ~32px */
            /* Vamos manter uma altura mínima para consistência visual, mesmo se vazia. */
            min-height: 35px;
            height: 35px; /* Altura fixa para a "pista" de tarefas */
        }
        .week-view-horizontal .task-block { /* Estilo base para os blocos de tarefa */
            position: absolute;
            height: 28px; /* Altura do bloco de tarefa aumentada ligeiramente */
            line-height: 24px; /* Para centralizar texto verticalmente se padding permitir */
            top: 2px; /* Pequeno espaço do topo da célula, pode ser ajustado para sobreposição */
            background-color: #a29bfe; /* Cor padrão do bloco */
            color: white;
            border-radius: 4px; /* Bordas mais arredondadas */
            padding: 0px 8px; /* Ajustado para melhor aparência com line-height */
            font-size: 0.75em; /* Aumentado para legibilidade */
            font-weight: 500;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            box-sizing: border-box;
            border: 1px solid rgba(0,0,0,0.2); /* Borda um pouco mais escura */
            box-shadow: 0 1px 2px rgba(0,0,0,0.1); /* Sombra sutil */
            z-index: 5; /* Para sobrepor linhas de grade e outros elementos */
            cursor: pointer;
        }
        .week-view-horizontal .task-block:hover {
            opacity: 0.85;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
        }
        .week-view-horizontal .task-block.priority-critical { background-color: #e74c3c; }
        .week-view-horizontal .task-block.priority-attention { background-color: #f39c12; }
        .week-view-horizontal .task-block.priority-normal { background-color: #2ecc71; }


        /* Relatórios */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background-color: white;
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .stat-title {
            font-size: 1rem;
            color: #666;
            margin-bottom: 0.5rem;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 600;
            color: #6a3093;
        }

        .chart-container {
            background-color: white;
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            margin-bottom: 1rem;
        }

        /* Botão flutuante de adicionar */
        .floating-btn {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: #6a3093;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            font-size: 1.5rem;
        }

        .floating-btn:hover {
            background-color: #8a4baf;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }

        /* Alertas e notificações */
        .alert {
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
        }

        .alert-success {
            background-color: rgba(46, 204, 113, 0.1);
            border-left: 4px solid #2ecc71;
            color: #27ae60;
        }

        .alert-warning {
            background-color: rgba(243, 156, 18, 0.1);
            border-left: 4px solid #f39c12;
            color: #e67e22;
        }

        .alert-danger {
            background-color: rgba(231, 76, 60, 0.1);
            border-left: 4px solid #e74c3c;
            color: #c0392b;
        }

        .alert-icon {
            margin-right: 0.5rem;
            font-size: 1.2rem;
        }

        /* Responsividade */
        @media (max-width: 768px) {
            .week-view {
                grid-template-columns: 1fr;
            }

            .week-day {
                margin-bottom: 1rem;
            }
        }

        function getWeekViewMode() {
            return localStorage.getItem('weekViewMode') || 'vertical'; // Padrão para vertical
        }

        function setWeekViewMode(mode) {
            localStorage.setItem('weekViewMode', mode);
            updateWeekViewToggleBtn(mode);
        }

        function updateWeekViewToggleBtn(mode) {
            if (mode === 'horizontal') {
                weekViewToggleText.textContent = 'Vertical';
                weekViewToggleIcon.innerHTML = '<path d="M10 4H6v16h4V4zm6 0h-4v16h4V4z"/>'; // Ícone para Vertical (colunas)
            } else { // vertical
                weekViewToggleText.textContent = 'Horizontal';
                weekViewToggleIcon.innerHTML = '<path d="M4 6h16v2H4zm0 5h16v2H4zm0 5h16v2H4z"/>'; // Ícone para Horizontal (linhas)
            }
        }

        /* Dias de recorrência */
        .recurrence-days {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .day-checkbox {
            display: none;
        }

        .day-label {
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background-color: #f0f0f0;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .day-checkbox:checked + .day-label {
            background-color: #6a3093;
            color: white;
        }

        /* Ícones */
        .icon {
            display: inline-block;
            width: 24px;
            height: 24px;
            stroke-width: 0;
            stroke: currentColor;
            fill: currentColor;
            line-height: 1;
        }

        .icon-sm {
            width: 18px;
            height: 18px;
        }

        .icon-lg {
            width: 30px;
            height: 30px;
        }

        /* Ocultar elementos */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- Cabeçalho do aplicativo -->
    <header class="app-header">
        <div class="header-controls">
            <h1 class="app-title">Agenda Diária</h1>
            <button class="settings-btn" id="settingsBtn">
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path>
                </svg>
            </button>
            <div class="settings-dropdown hidden" id="settingsDropdown">
                <button id="retention90days">Retenção: 90 dias</button>
                <button id="retention180days">Retenção: 180 dias</button>
                <button id="retentionDefault">Retenção: 30 dias (Padrão)</button>
                <hr>
                <button id="deleteAllDataBtn" style="color: #e74c3c;">Excluir Todos os Dados</button>
            </div>
        </div>
        <div class="date-nav">
            <button class="nav-btn" id="prevDay">
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path>
                </svg>
            </button>
            <div class="date-display" id="currentDate">carregando...</div>
            <button class="nav-btn" id="nextDay">
                <svg class="icon" viewBox="0 0 24 24">
                    <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"></path>
                </svg>
            </button>
        </div>
    </header>

    <!-- Navegação principal -->
    <nav class="main-nav">
        <div class="nav-tab active" data-tab="agenda">
            <svg class="icon icon-sm" viewBox="0 0 24 24">
                <path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM5 5v2h14V5H5z"></path>
            </svg>
            Agenda
        </div>
        <div class="nav-tab" data-tab="semana">
            <svg class="icon icon-sm" viewBox="0 0 24 24">
                <path d="M4 11h5V5H4v6zm0 7h5v-6H4v6zm6 0h5v-6h-5v6zm6 0h5v-6h-5v6zm-6-7h5V5h-5v6zm6-6v6h5V5h-5z"></path>
            </svg>
            Semana
        </div>
        <div class="nav-tab" data-tab="relatorios">
            <svg class="icon icon-sm" viewBox="0 0 24 24">
                <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z"></path>
            </svg>
            Relatórios
        </div>
    </nav>

    <!-- Conteúdo principal -->
    <main class="content">
        <!-- Seção Agenda (visível por padrão) -->
        <section id="agenda-section" class="tab-content">
            <div id="tasks-container" class="task-list">
                <!-- As tarefas serão inseridas aqui dinamicamente -->
                <div class="alert alert-info">
                    <svg class="icon alert-icon" viewBox="0 0 24 24">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"></path>
                    </svg>
                    <div>Nenhuma tarefa para hoje. Adicione uma nova tarefa clicando no botão +</div>
                </div>
            </div>
        </section>

        <!-- Seção Semana (inicialmente oculta) -->
        <section id="semana-section" class="tab-content hidden">
            <div class="view-toggle-container" style="display: flex; justify-content: flex-end; margin-bottom: 1rem;">
                <button id="weekViewToggleBtn" class="btn btn-secondary btn-sm">
                    <svg class="icon icon-sm btn-icon" id="weekViewToggleIcon" viewBox="0 0 24 24">
                        <path d="M4 6h16v2H4zm0 5h16v2H4zm0 5h16v2H4z"/> <!-- Ícone para Horizontal (linhas) -->
                    </svg>
                    <span id="weekViewToggleText">Horizontal</span>
                </button>
            </div>
            <div class="week-view" id="week-view-container">
                <!-- Os dias da semana serão inseridos aqui dinamicamente -->
            </div>
        </section>

        <!-- Seção Relatórios (inicialmente oculta) -->
        <section id="relatorios-section" class="tab-content hidden">
            <h2 class="section-title">Resumo de Atividades</h2>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-title">Tarefas concluídas esta semana</div>
                    <div class="stat-value" id="tasks-completed">0</div>
                    <div class="stat-subtitle" id="tasks-completed-ratio">concluídas de 0 tarefas</div>
                </div>

                <div class="stat-card">
                    <div class="stat-title">Pontualidade</div>
                    <div class="stat-value" id="tasks-on-time">0</div>
                    <div class="stat-subtitle" id="tasks-on-time-ratio">no horário de 0 executadas</div>
                </div>
            </div>

            <div class="chart-container">
                <h3 class="chart-title">Distribuição por Prioridade</h3>
                <div class="chart-content">
                    <div>Crítica <span id="priority-critical-percent">0%</span></div>
                    <div>Atenção <span id="priority-attention-percent">0%</span></div>
                    <div>Normal <span id="priority-normal-percent">0%</span></div>
                </div>
            </div>
        </section>
    </main>

    <!-- Botão flutuante de adicionar tarefa -->
    <button class="floating-btn" id="addTaskBtn">
        <svg class="icon" viewBox="0 0 24 24">
            <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path>
        </svg>
    </button>

    <!-- Modal de Adicionar/Editar Tarefa -->
    <div class="modal-overlay" id="taskModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title" id="taskModalTitle">Adicionar Nova Tarefa</h3>
                <button class="modal-close" id="closeTaskModal">&times;</button>
            </div>
            <form id="taskForm">
                <input type="hidden" id="taskId">
                <div class="form-group">
                    <label class="form-label" for="taskTitle">Título*</label>
                    <input type="text" class="form-control" id="taskTitle" required>
                </div>
                <div class="form-group">
                    <label class="form-label" for="taskDescription">Descrição</label>
                    <textarea class="form-control" id="taskDescription" rows="3"></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Horário*</label>
                    <div class="flex" style="display: flex; gap: 10px;">
                        <div style="flex: 1;">
                            <label class="form-label" for="taskStartTime">Início</label>
                            <input type="time" class="form-control" id="taskStartTime" required>
                        </div>
                        <div style="flex: 1;">
                            <label class="form-label" for="taskEndTime">Fim</label>
                            <input type="time" class="form-control" id="taskEndTime" required>
                        </div>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label" for="taskPriority">Prioridade*</label>
                    <select class="form-select" id="taskPriority" required>
                        <option value="normal">Normal</option>
                        <option value="attention">Atenção</option>
                        <option value="critical">Crítica</option>
                    </select>
                </div>
                <div class="form-group">
                    <div class="form-check">
                        <input type="checkbox" id="taskRecurrent" class="form-check-input">
                        <label for="taskRecurrent" class="form-check-label">Tarefa Recorrente</label>
                    </div>
                </div>
                <div id="recurrenceOptions" class="hidden">
                    <div class="form-group">
                        <div class="form-check">
                            <input type="radio" name="recurrenceType" id="recurrenceDaily" value="daily" class="form-check-input" checked>
                            <label for="recurrenceDaily" class="form-check-label">Todos os dias</label>
                        </div>
                        <div class="form-check">
                            <input type="radio" name="recurrenceType" id="recurrenceSpecific" value="specific" class="form-check-input">
                            <label for="recurrenceSpecific" class="form-check-label">Dias específicos</label>
                        </div>
                    </div>
                    <div id="specificDays" class="hidden">
                        <div class="recurrence-days">
                            <input type="checkbox" id="day-0" class="day-checkbox" value="0">
                            <label for="day-0" class="day-label">D</label>

                            <input type="checkbox" id="day-1" class="day-checkbox" value="1">
                            <label for="day-1" class="day-label">S</label>

                            <input type="checkbox" id="day-2" class="day-checkbox" value="2">
                            <label for="day-2" class="day-label">T</label>

                            <input type="checkbox" id="day-3" class="day-checkbox" value="3">
                            <label for="day-3" class="day-label">Q</label>

                            <input type="checkbox" id="day-4" class="day-checkbox" value="4">
                            <label for="day-4" class="day-label">Q</label>

                            <input type="checkbox" id="day-5" class="day-checkbox" value="5">
                            <label for="day-5" class="day-label">S</label>

                            <input type="checkbox" id="day-6" class="day-checkbox" value="6">
                            <label for="day-6" class="day-label">S</label>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="cancelTaskBtn">Cancelar</button>
                    <button type="submit" class="btn btn-primary" id="saveTaskBtn">
                        <svg class="icon icon-sm btn-icon" viewBox="0 0 24 24">
                            <path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"></path>
                        </svg>
                        Salvar
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Modal de Comentários -->
    <div class="modal-overlay" id="commentsModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Comentários</h3>
                <button class="modal-close" id="closeCommentsModal">&times;</button>
            </div>
            <div class="comments-section">
                <ul class="comment-list" id="commentsList">
                    <!-- Os comentários serão inseridos aqui dinamicamente -->
                </ul>

                <form id="commentForm">
                    <input type="hidden" id="commentTaskId">
                    <div class="form-group">
                        <label class="form-label" for="commentText">Novo comentário</label>
                        <textarea class="form-control" id="commentText" rows="2" required></textarea>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="commentImage">Imagem (opcional)</label>
                        <input type="file" class="form-control" id="commentImage" accept="image/*">
                    </div>
                    <div class="modal-footer">
                        <button type="submit" class="btn btn-primary" id="addCommentBtn">
                            <svg class="icon icon-sm btn-icon" viewBox="0 0 24 24">
                                <path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-2 12H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"></path>
                            </svg>
                            Adicionar Comentário
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Modal de Confirmação Genérico -->
    <div class="modal-overlay" id="confirmationModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title" id="confirmationModalTitle">Confirmar Ação</h3>
                <button class="modal-close" id="closeConfirmationModal">&times;</button>
            </div>
            <div class="modal-body" id="confirmationModalBody">
                Tem certeza que deseja prosseguir?
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" id="confirmNoBtn">Não</button>
                <button type="button" class="btn btn-primary" id="confirmYesBtn">Sim</button>
            </div>
        </div>
    </div>

    <script>
        // Constantes e Variáveis Globais
        const monthNames = [
            "janeiro", "fevereiro", "março", "abril", "maio", "junho",
            "julho", "agosto", "setembro", "outubro", "novembro", "dezembro"
        ];

        const dayNames = [
            "domingo", "segunda-feira", "terça-feira", "quarta-feira",
            "quinta-feira", "sexta-feira", "sábado"
        ];

        const shortDayNames = ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"];

        // Estado da aplicação
        let currentDate = new Date();
        let tasks = [];
        let editingTaskId = null;

        // Constantes para a Grade Horizontal da Semana
        const HORIZONTAL_VIEW_START_HOUR = 5; // 5:00
        const HORIZONTAL_VIEW_END_HOUR = 22; // até 22:00 (exclusive, então a última coluna será 21:00-22:00)
        const HOUR_COLUMN_COUNT = HORIZONTAL_VIEW_END_HOUR - HORIZONTAL_VIEW_START_HOUR;


        // Elementos DOM
        const currentDateEl = document.getElementById('currentDate');
        const prevDayBtn = document.getElementById('prevDay');
        const nextDayBtn = document.getElementById('nextDay');
        const tasksContainer = document.getElementById('tasks-container');
        const weekViewContainer = document.getElementById('week-view-container');
        const addTaskBtn = document.getElementById('addTaskBtn');
        const taskModal = document.getElementById('taskModal');
        const closeTaskModal = document.getElementById('closeTaskModal');
        const cancelTaskBtn = document.getElementById('cancelTaskBtn');
        const taskForm = document.getElementById('taskForm');
        const taskModalTitle = document.getElementById('taskModalTitle');
        const taskIdInput = document.getElementById('taskId');
        const taskTitleInput = document.getElementById('taskTitle');
        const taskDescriptionInput = document.getElementById('taskDescription');
        const taskStartTimeInput = document.getElementById('taskStartTime');
        const taskEndTimeInput = document.getElementById('taskEndTime');
        const taskPriorityInput = document.getElementById('taskPriority');
        const taskRecurrentInput = document.getElementById('taskRecurrent');
        const recurrenceOptions = document.getElementById('recurrenceOptions');
        const recurrenceDailyInput = document.getElementById('recurrenceDaily');
        const recurrenceSpecificInput = document.getElementById('recurrenceSpecific');
        const specificDays = document.getElementById('specificDays');
        const commentsModal = document.getElementById('commentsModal');
        const closeCommentsModal = document.getElementById('closeCommentsModal');
        const commentsList = document.getElementById('commentsList');
        const commentForm = document.getElementById('commentForm');
        const commentTaskIdInput = document.getElementById('commentTaskId');
        const commentTextInput = document.getElementById('commentText');
        const commentImageInput = document.getElementById('commentImage');
        const navTabs = document.querySelectorAll('.nav-tab');
        const tabContents = document.querySelectorAll('.tab-content');

        // Elementos de Configurações
        const settingsBtn = document.getElementById('settingsBtn');
        const settingsDropdown = document.getElementById('settingsDropdown');
        const retention90daysBtn = document.getElementById('retention90days');
        const retention180daysBtn = document.getElementById('retention180days');
        const retentionDefaultBtn = document.getElementById('retentionDefault');
        const deleteAllDataBtn = document.getElementById('deleteAllDataBtn');

        // Elementos do Toggle da Visualização Semanal
        const weekViewToggleBtn = document.getElementById('weekViewToggleBtn');
        const weekViewToggleIcon = document.getElementById('weekViewToggleIcon');
        const weekViewToggleText = document.getElementById('weekViewToggleText');

        // Elementos do Modal de Confirmação
        const confirmationModal = document.getElementById('confirmationModal');
        const confirmationModalTitle = document.getElementById('confirmationModalTitle');
        const confirmationModalBody = document.getElementById('confirmationModalBody');
        const closeConfirmationModal = document.getElementById('closeConfirmationModal');
        const confirmYesBtn = document.getElementById('confirmYesBtn');
        const confirmNoBtn = document.getElementById('confirmNoBtn');
        let currentConfirmCallback = null;


        // Estatísticas
        const tasksCompletedEl = document.getElementById('tasks-completed');
        const tasksCompletedRatioEl = document.getElementById('tasks-completed-ratio');
        const tasksOnTimeEl = document.getElementById('tasks-on-time');
        const tasksOnTimeRatioEl = document.getElementById('tasks-on-time-ratio');
        const priorityCriticalPercentEl = document.getElementById('priority-critical-percent');
        const priorityAttentionPercentEl = document.getElementById('priority-attention-percent');
        const priorityNormalPercentEl = document.getElementById('priority-normal-percent');

        // Inicialização da Aplicação
        document.addEventListener('DOMContentLoaded', () => {
            updateDateDisplay();
            setupEventListeners();
            updateRetentionDropdownUI(getDataRetentionDays());
            updateWeekViewToggleBtn(getWeekViewMode()); // Atualizar botão toggle na carga
            setupFirestoreListener();
        });

        function setupFirestoreListener() {
            const { collection, onSnapshot, Timestamp } = window.firebaseFirestore;
            const tasksCol = collection(window.db, "tasks");

            onSnapshot(tasksCol, (snapshot) => {
                console.log("Dados do Firestore atualizados em tempo real.");
                tasks = snapshot.docs.map(doc => {
                    const data = doc.data();
                    const convertTimestampToDate = (timestamp) => {
                        if (timestamp && typeof timestamp.toDate === 'function') {
                            return timestamp.toDate();
                        }
                        if (timestamp instanceof Date) return timestamp;
                        if (typeof timestamp === 'string') {
                            const parsedDate = new Date(timestamp);
                            return isNaN(parsedDate.getTime()) ? null : parsedDate;
                        }
                        return null;
                    };

                    const validComments = Array.isArray(data.comments) ? data.comments.filter(comment => {
                        if (!comment || !comment.timestamp) return false;
                        const tsDate = convertTimestampToDate(comment.timestamp);
                        return tsDate instanceof Date && !isNaN(tsDate.getTime());
                    }) : [];

                    return {
                        id: doc.id,
                        ...data,
                        date: convertTimestampToDate(data.date),
                        realStartTime: data.realStartTime ? convertTimestampToDate(data.realStartTime) : null,
                        realEndTime: data.realEndTime ? convertTimestampToDate(data.realEndTime) : null,
                        comments: validComments.map(comment => ({
                            ...comment,
                            timestamp: convertTimestampToDate(comment.timestamp)
                        }))
                    };
                }).filter(task => task.date instanceof Date && !isNaN(task.date.getTime()));

                renderTasks();
                renderWeekView();
                updateStatistics();

                // Chamar a exclusão de tarefas antigas após o primeiro carregamento/atualização
                // Para evitar múltiplas chamadas desnecessárias, podemos adicionar um flag
                if (!window.initialTasksLoaded) {
                    deleteOldTasks();
                    window.initialTasksLoaded = true;
                }

            }, (error) => {
                console.error("Erro no listener do Firestore: ", error);
            });
        }

        async function deleteOldTasks() {
            const { deleteDoc, doc } = window.firebaseFirestore;
            const retentionDays = getDataRetentionDays();
            const now = new Date();
            const limitDate = new Date(now.setDate(now.getDate() - retentionDays));
            limitDate.setHours(0, 0, 0, 0); // Comparar apenas a data

            console.log(`Verificando tarefas para excluir anteriores a: ${limitDate.toLocaleDateString()}`);

            const tasksToDelete = tasks.filter(task => {
                if (!task.date) return false; // Ignorar tarefas sem data
                const taskDate = task.date instanceof Date ? task.date : new Date(task.date);
                return taskDate < limitDate;
            });

            if (tasksToDelete.length > 0) {
                console.log(`Excluindo ${tasksToDelete.length} tarefas antigas...`);
                // Usar Promise.all para aguardar todas as exclusões
                try {
                    await Promise.all(tasksToDelete.map(task => {
                        console.log(`Excluindo tarefa: ${task.title} (ID: ${task.id}) de ${task.date.toLocaleDateString()}`);
                        return deleteDoc(doc(window.db, "tasks", task.id));
                    }));
                    console.log(`${tasksToDelete.length} tarefas antigas excluídas com sucesso.`);
                    await loadTasks(); // Recarregar tarefas para atualizar a UI
                } catch (error) {
                    console.error("Erro ao excluir tarefas antigas:", error);
                }
            } else {
                console.log("Nenhuma tarefa antiga para excluir.");
            }
        }


        // Funções para controle da visualização da semana
        function getWeekViewMode() {
            return localStorage.getItem('weekViewMode') || 'vertical'; // Padrão para vertical
        }

        function updateWeekViewToggleBtn(mode) {
            if (!weekViewToggleText || !weekViewToggleIcon) return; // Guard clause
            if (mode === 'horizontal') {
                weekViewToggleText.textContent = 'Vertical';
                weekViewToggleIcon.innerHTML = '<path d="M10 4H6v16h4V4zm6 0h-4v16h4V4z"/>'; // Ícone para Vertical (colunas)
            } else { // vertical
                weekViewToggleText.textContent = 'Horizontal';
                weekViewToggleIcon.innerHTML = '<path d="M4 6h16v2H4zm0 5h16v2H4zm0 5h16v2H4z"/>'; // Ícone para Horizontal (linhas)
            }
        }

        function setWeekViewMode(mode) {
            localStorage.setItem('weekViewMode', mode);
            updateWeekViewToggleBtn(mode);
        }
        // Fim das funções para controle da visualização da semana

        // Funções principais
        function setupEventListeners() {
            prevDayBtn.addEventListener('click', () => {
                const activeTab = document.querySelector('.nav-tab.active')?.dataset.tab;
                if (activeTab === 'semana') {
                    currentDate.setDate(currentDate.getDate() - 7);
                    // Ajustar para a segunda-feira da semana
                    const dayOfWeek = currentDate.getDay(); // 0 (Dom) - 6 (Sáb)
                    const diffToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek; // Se Dom, volta 6 dias, senão, vai para Seg
                    currentDate.setDate(currentDate.getDate() + diffToMonday);
                    updateDateDisplay();
                    renderWeekView();
                } else {
                    currentDate.setDate(currentDate.getDate() - 1);
                    updateDateDisplay();
                    renderTasks();
                }
            });

            nextDayBtn.addEventListener('click', () => {
                const activeTab = document.querySelector('.nav-tab.active')?.dataset.tab;
                if (activeTab === 'semana') {
                    currentDate.setDate(currentDate.getDate() + 7);
                     // Ajustar para a segunda-feira da semana
                    const dayOfWeek = currentDate.getDay();
                    const diffToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
                    currentDate.setDate(currentDate.getDate() + diffToMonday);
                    updateDateDisplay();
                    renderWeekView();
                } else {
                    currentDate.setDate(currentDate.getDate() + 1);
                    updateDateDisplay();
                    renderTasks();
                }
            });

            navTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    navTabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    tabContents.forEach(content => content.classList.add('hidden'));
                    const tabId = tab.dataset.tab;
                    document.getElementById(`${tabId}-section`).classList.remove('hidden');

                    if (tabId === 'agenda') {
                        document.body.classList.remove('week-horizontal-view-active');
                        currentDate = new Date(); // Resetar para data de hoje
                        updateDateDisplay();
                        renderTasks();
                    } else if (tabId === 'semana') {
                        // A classe week-horizontal-view-active é gerenciada em renderWeekViewHorizontal/Vertical
                        const dayOfWeek = currentDate.getDay();
                        const diffToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
                        currentDate.setDate(currentDate.getDate() + diffToMonday);
                        updateDateDisplay(); // Atualizar display de data para o intervalo da semana
                        renderWeekView();
                    } else if (tabId === 'relatorios') {
                        document.body.classList.remove('week-horizontal-view-active');
                        updateStatistics();
                    }
                });
            });

            addTaskBtn.addEventListener('click', () => openTaskModal());
            closeTaskModal.addEventListener('click', () => taskModal.style.display = 'none');
            cancelTaskBtn.addEventListener('click', () => taskModal.style.display = 'none');
            taskForm.addEventListener('submit', (e) => {
                e.preventDefault();
                saveTask();
            });

            taskRecurrentInput.addEventListener('change', () => recurrenceOptions.classList.toggle('hidden', !taskRecurrentInput.checked));
            recurrenceSpecificInput.addEventListener('change', () => specificDays.classList.toggle('hidden', !recurrenceSpecificInput.checked));
            recurrenceDailyInput.addEventListener('change', () => specificDays.classList.add('hidden'));

            closeCommentsModal.addEventListener('click', () => commentsModal.style.display = 'none');
            commentForm.addEventListener('submit', (e) => {
                e.preventDefault();
                addComment();
            });

            window.addEventListener('click', (e) => {
                if (e.target === taskModal) taskModal.style.display = 'none';
                if (e.target === commentsModal) commentsModal.style.display = 'none';
                // Fechar dropdown de configurações se clicar fora
                if (settingsDropdown && !settingsDropdown.classList.contains('hidden') && !settingsBtn.contains(e.target) && !settingsDropdown.contains(e.target)) {
                    settingsDropdown.classList.add('hidden');
                }
            });

            settingsBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Evitar que o window click listener feche imediatamente
                settingsDropdown.classList.toggle('hidden');
            });

            // Event listeners para os botões do dropdown de configurações
            retentionDefaultBtn.addEventListener('click', () => setDataRetention(30));
            retention90daysBtn.addEventListener('click', () => setDataRetention(90));
            retention180daysBtn.addEventListener('click', () => setDataRetention(180));
            deleteAllDataBtn.addEventListener('click', () => confirmDeleteAllData());

            weekViewToggleBtn.addEventListener('click', () => {
                const currentMode = getWeekViewMode();
                const newMode = currentMode === 'vertical' ? 'horizontal' : 'vertical';
                setWeekViewMode(newMode);
                renderWeekView(); // Re-renderiza a visualização da semana
            });

            // Event listeners do Modal de Confirmação
            closeConfirmationModal.addEventListener('click', () => hideConfirmationModal());
            confirmNoBtn.addEventListener('click', () => hideConfirmationModal());
            confirmYesBtn.addEventListener('click', () => {
                if (currentConfirmCallback) {
                    currentConfirmCallback();
                }
                hideConfirmationModal();
            });
            confirmationModal.addEventListener('click', (e) => { // Fechar ao clicar no overlay
                if (e.target === confirmationModal) {
                    hideConfirmationModal();
                }
            });
        }

        function showConfirmationModal(message, callback, title = "Confirmar Ação") {
            confirmationModalTitle.textContent = title;
            confirmationModalBody.textContent = message;
            currentConfirmCallback = callback;
            confirmationModal.style.display = 'flex';
            settingsDropdown.classList.add('hidden'); // Esconder dropdown de configurações
        }

        function hideConfirmationModal() {
            confirmationModal.style.display = 'none';
            currentConfirmCallback = null;
        }

        function setDataRetention(days) {
            const message = `Deseja alterar o período de retenção de dados para ${days} dias? Tarefas mais antigas que ${days} dias serão excluídas na próxima vez que a página for carregada (ou ao definir esta opção).`;
            showConfirmationModal(message, () => {
                localStorage.setItem('dataRetentionDays', days.toString());
                console.log(`Período de retenção de dados alterado para ${days} dias.`);
                updateRetentionDropdownUI(days);
                // Opcionalmente, chamar deleteOldTasks() aqui imediatamente ou apenas na próxima carga.
                // Por enquanto, vamos manter a exclusão apenas no carregamento da página.
                hideConfirmationModal(); // Garantir que o modal de confirmação seja fechado
            }, "Confirmar Retenção de Dados");
        }

        function getDataRetentionDays() {
            return parseInt(localStorage.getItem('dataRetentionDays') || '30', 10);
        }

        function updateRetentionDropdownUI(currentRetentionDays) {
            // Remover destaque de todos
            [retentionDefaultBtn, retention90daysBtn, retention180daysBtn].forEach(btn => {
                btn.style.fontWeight = 'normal';
                btn.style.backgroundColor = ''; // Limpar background
            });

            // Destacar o botão ativo
            let activeBtn;
            if (currentRetentionDays === 90) {
                activeBtn = retention90daysBtn;
            } else if (currentRetentionDays === 180) {
                activeBtn = retention180daysBtn;
            } else { // 30 dias ou padrão
                activeBtn = retentionDefaultBtn;
            }
            if (activeBtn) {
                activeBtn.style.fontWeight = 'bold';
                activeBtn.style.backgroundColor = '#e0e0e0'; // Um leve destaque
            }
        }


        function updateDateDisplay() {
            const activeTab = document.querySelector('.nav-tab.active')?.dataset.tab;
            if (activeTab === 'semana') {
                let startOfWeek = new Date(currentDate);
                const dayOfWeek = startOfWeek.getDay();
                const diffToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
                startOfWeek.setDate(startOfWeek.getDate() + diffToMonday);

                let endOfWeek = new Date(startOfWeek);
                endOfWeek.setDate(startOfWeek.getDate() + 6);

                currentDateEl.textContent =
                    `${startOfWeek.getDate()} de ${monthNames[startOfWeek.getMonth()].substring(0,3)}` +
                    ` - ${endOfWeek.getDate()} de ${monthNames[endOfWeek.getMonth()].substring(0,3)} de ${endOfWeek.getFullYear()}`;
            } else {
                const day = currentDate.getDate();
                const month = monthNames[currentDate.getMonth()];
                const year = currentDate.getFullYear();
                const weekday = dayNames[currentDate.getDay()];
                currentDateEl.textContent = `${weekday}, ${day} de ${month} de ${year}`;
            }
        }

        function formatDate(date) {
            if (!(date instanceof Date) || isNaN(date.getTime())) return null; // Validação
            const day = date.getDate().toString().padStart(2, '0');
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const year = date.getFullYear();
            return `${year}-${month}-${day}`;
        }

        function formatTime(timeString) {
            const [hours, minutes] = timeString.split(':');
            return `${hours}:${minutes}`;
        }

        function isToday(date) {
            if (!(date instanceof Date) || isNaN(date.getTime())) return false;
            const today = new Date();
            return date.getDate() === today.getDate() &&
                   date.getMonth() === today.getMonth() &&
                   date.getFullYear() === today.getFullYear();
        }

        function isPast(date) {
            if (!(date instanceof Date) || isNaN(date.getTime())) return false;
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const compareDate = new Date(date); // Clonar para não modificar a original
            compareDate.setHours(0,0,0,0);
            return compareDate < today;
        }

        // Converte objetos Date para Timestamps do Firestore ANTES de salvar
        function convertToFirestoreTimestamps(taskData) {
            const { Timestamp } = window.firebaseFirestore;
            const dataToSave = { ...taskData };

            if (dataToSave.date instanceof Date) {
                dataToSave.date = Timestamp.fromDate(dataToSave.date);
            }
            if (dataToSave.realStartTime instanceof Date) {
                dataToSave.realStartTime = Timestamp.fromDate(dataToSave.realStartTime);
            }
            if (dataToSave.realEndTime instanceof Date) {
                dataToSave.realEndTime = Timestamp.fromDate(dataToSave.realEndTime);
            }
            if (Array.isArray(dataToSave.comments)) {
                dataToSave.comments = dataToSave.comments.map(comment => {
                    if (comment.timestamp instanceof Date) {
                        return { ...comment, timestamp: Timestamp.fromDate(comment.timestamp) };
                    }
                    return comment;
                });
            }
            return dataToSave;
        }

        // Manipulação de Tarefas com Firestore
        async function loadTasks() {
            const { getDocs, collection, Timestamp } = window.firebaseFirestore;
            const tasksCol = collection(window.db, "tasks");
            try {
                const taskSnapshot = await getDocs(tasksCol);
                tasks = taskSnapshot.docs.map(doc => {
                    const data = doc.data();

                    const convertTimestampToDate = (timestamp) => {
                        if (timestamp && typeof timestamp.toDate === 'function') {
                            return timestamp.toDate();
                        }
                        if (timestamp instanceof Date) return timestamp;
                        if (typeof timestamp === 'string') {
                            const parsedDate = new Date(timestamp);
                            return isNaN(parsedDate.getTime()) ? null : parsedDate;
                        }
                        return null;
                    };

                    const validComments = Array.isArray(data.comments) ? data.comments.filter(comment => {
                        if (!comment || !comment.timestamp) return false;
                        const tsDate = convertTimestampToDate(comment.timestamp);
                        return tsDate instanceof Date && !isNaN(tsDate.getTime());
                    }) : [];

                    return {
                        id: doc.id, // Armazenar o ID do documento Firestore
                        ...data,
                        date: convertTimestampToDate(data.date),
                        realStartTime: data.realStartTime ? convertTimestampToDate(data.realStartTime) : null,
                        realEndTime: data.realEndTime ? convertTimestampToDate(data.realEndTime) : null,
                        comments: validComments.map(comment => ({
                            ...comment,
                            timestamp: convertTimestampToDate(comment.timestamp)
                        }))
                    };
                }).filter(task => task.date instanceof Date && !isNaN(task.date.getTime())); // Garantir que a tarefa tenha uma data válida
            } catch (error) {
                console.error("Erro ao carregar tarefas do Firestore:", error);
                tasks = [];
            }

            renderTasks();
            renderWeekView();
            updateStatistics();
        }

        // saveTasks não é mais necessária para salvar tudo, as operações são individuais.
        // Pode ser mantida como um placeholder ou removida se não houver planos para operações em lote.
        async function saveTasks() {
            console.log("saveTasks: Operações de escrita são individuais e diretas ao Firestore.");
        }

        function openTaskModal(taskId = null) {
            taskForm.reset();
            recurrenceOptions.classList.add('hidden');
            specificDays.classList.add('hidden');
            editingTaskId = taskId;

            if (taskId) {
                const task = tasks.find(t => t.id === taskId);
                if (task) {
                    taskModalTitle.textContent = 'Editar Tarefa';
                    taskIdInput.value = task.id; // ID do Firestore
                    taskTitleInput.value = task.title;
                    taskDescriptionInput.value = task.description || '';
                    taskStartTimeInput.value = task.startTime;
                    taskEndTimeInput.value = task.endTime;
                    taskPriorityInput.value = task.priority;
                    taskRecurrentInput.checked = task.recurrent;
                    if (task.recurrent) {
                        recurrenceOptions.classList.remove('hidden');
                        if (task.recurrenceType === 'daily') {
                            recurrenceDailyInput.checked = true;
                        } else {
                            recurrenceSpecificInput.checked = true;
                            specificDays.classList.remove('hidden');
                            document.querySelectorAll('.day-checkbox').forEach(checkbox => {
                                checkbox.checked = task.recurringDays && task.recurringDays.includes(parseInt(checkbox.value));
                            });
                        }
                    }
                }
            } else {
                taskModalTitle.textContent = 'Adicionar Nova Tarefa';
                taskIdInput.value = ''; // Limpar para nova tarefa
                const now = new Date();
                const nextHour = new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours() + 1, 0);
                const endHour = new Date(nextHour.getTime() + 60 * 60 * 1000);
                taskStartTimeInput.value = `${nextHour.getHours().toString().padStart(2, '0')}:00`;
                taskEndTimeInput.value = `${endHour.getHours().toString().padStart(2, '0')}:00`;
            }
            taskModal.style.display = 'flex';
        }

        async function saveTask() {
            const { addDoc, updateDoc, doc, collection, Timestamp } = window.firebaseFirestore;
            const title = taskTitleInput.value.trim();
            const description = taskDescriptionInput.value.trim();
            const startTime = taskStartTimeInput.value;
            const endTime = taskEndTimeInput.value;
            const priority = taskPriorityInput.value;
            const recurrent = taskRecurrentInput.checked;

            if (startTime >= endTime) {
                alert('O horário de início deve ser anterior ao horário de fim.');
                return;
            }

            // Validação de Sobreposição de Horário
            const newTaskDateStr = formatDate(editingTaskId ? (tasks.find(t => t.id === editingTaskId)?.date || new Date(currentDate)) : new Date(currentDate));
            const newTaskStartMinutes = parseInt(startTime.split(':')[0]) * 60 + parseInt(startTime.split(':')[1]);
            const newTaskEndMinutes = parseInt(endTime.split(':')[0]) * 60 + parseInt(endTime.split(':')[1]);

            for (const existingTask of tasks) {
                if (editingTaskId === existingTask.id) continue; // Não comparar com a própria tarefa ao editar

                const existingTaskDateStr = formatDate(existingTask.date);
                if (newTaskDateStr === existingTaskDateStr) {
                    const existingTaskStartMinutes = parseInt(existingTask.startTime.split(':')[0]) * 60 + parseInt(existingTask.startTime.split(':')[1]);
                    const existingTaskEndMinutes = parseInt(existingTask.endTime.split(':')[0]) * 60 + parseInt(existingTask.endTime.split(':')[1]);

                    // Verifica sobreposição: (StartA < EndB) and (EndA > StartB)
                    if (newTaskStartMinutes < existingTaskEndMinutes && newTaskEndMinutes > existingTaskStartMinutes) {
                        alert(`Erro: O horário desta tarefa (${startTime} - ${endTime}) sobrepõe a tarefa existente "${existingTask.title}" (${existingTask.startTime} - ${existingTask.endTime}) no mesmo dia. Ajuste os horários.`);
                        return; // Impede o salvamento
                    }
                }
            }

            let recurrenceType = null;
            let recurringDays = null;
            if (recurrent) {
                recurrenceType = recurrenceDailyInput.checked ? 'daily' : 'specific';
                if (recurrenceType === 'specific') {
                    recurringDays = Array.from(document.querySelectorAll('.day-checkbox:checked')).map(cb => parseInt(cb.value));
                    if (recurringDays.length === 0) {
                        alert('Selecione pelo menos um dia para recorrência específica.');
                        return;
                    }
                }
            }

            const taskDataToSave = {
                // Não inclua 'id' aqui, Firestore gera automaticamente ou usa o 'editingTaskId' para o 'docRef'
                date: new Date(currentDate), // Usar a data atual da visualização para novas tarefas
                title,
                description,
                startTime,
                endTime,
                priority,
                status: 'pending', // Status padrão para novas tarefas
                comments: editingTaskId ? (tasks.find(t => t.id === editingTaskId)?.comments || []) : [], // Manter comentários existentes ao editar
                recurrent,
                recurrenceType,
                recurringDays,
                // Campos de tempo real são definidos em start/finish Task
                realStartTime: editingTaskId ? (tasks.find(t => t.id === editingTaskId)?.realStartTime || null) : null,
                realEndTime: editingTaskId ? (tasks.find(t => t.id === editingTaskId)?.realEndTime || null) : null,
            };

            // Se estiver editando, a data da tarefa não deve ser alterada para 'currentDate'
            // a menos que seja explicitamente parte da edição (o que não é o caso aqui).
            // A data original da tarefa deve ser preservada.
            if (editingTaskId) {
                 const existingTask = tasks.find(t => t.id === editingTaskId);
                 if (existingTask) {
                    taskDataToSave.date = existingTask.date; // Preservar a data original
                    taskDataToSave.status = existingTask.status; // Preservar status
                 }
            }


            const firestoreReadyData = convertToFirestoreTimestamps(taskDataToSave);

            try {
                if (editingTaskId) {
                    const taskDocRef = doc(window.db, "tasks", editingTaskId);
                    await updateDoc(taskDocRef, firestoreReadyData);
                } else {
                    const docRef = await addDoc(collection(window.db, "tasks"), firestoreReadyData);
                    // Se for recorrente, criar instâncias após salvar a principal e obter o ID
                    if (recurrent) {
                         // Passar o ID da tarefa pai e os dados da tarefa pai para criar instâncias
                        createRecurringInstances({ ...taskDataToSave, id: docRef.id, date: new Date(taskDataToSave.date) });
                    }
                }
                await loadTasks(); // Recarregar tarefas do Firestore para atualizar a UI
            } catch (error) {
                console.error("Erro ao salvar tarefa no Firestore: ", error);
            }

            taskModal.style.display = 'none';
        }

        async function createRecurringInstances(parentTask) {
            const { addDoc, collection, Timestamp } = window.firebaseFirestore;
            const futureLimit = new Date(parentTask.date); // Usar a data da tarefa pai como base
            futureLimit.setDate(futureLimit.getDate() + 30);

            const startDate = new Date(parentTask.date);
            startDate.setDate(startDate.getDate() + 1);

            for (let date = new Date(startDate); date <= futureLimit; date.setDate(date.getDate() + 1)) {
                const dayOfWeek = date.getDay();
                if (parentTask.recurrenceType === 'daily' ||
                    (parentTask.recurrenceType === 'specific' && parentTask.recurringDays.includes(dayOfWeek))) {

                    const instanceTaskData = {
                        parentTaskId: parentTask.id, // ID da tarefa pai
                        date: Timestamp.fromDate(new Date(date)), // Salvar como Timestamp
                        title: parentTask.title,
                        description: parentTask.description,
                        startTime: parentTask.startTime,
                        endTime: parentTask.endTime,
                        priority: parentTask.priority,
                        status: 'pending',
                        comments: [], // Instâncias não herdam comentários
                        recurrent: false // Instâncias não são recorrentes por si
                    };
                    try {
                        await addDoc(collection(window.db, "tasks"), instanceTaskData);
                    } catch (error) {
                        console.error("Erro ao criar instância recorrente:", error);
                    }
                }
            }
            await loadTasks(); // Recarregar para mostrar novas instâncias
        }

        // updateRecurringInstances precisaria ser reavaliado.
        // Uma abordagem mais simples seria deletar e recriar instâncias futuras se o padrão de recorrência mudar.
        // Ou, para edições de título/descrição, atualizar todas as instâncias futuras.
        // Por simplicidade, a edição de recorrência pode ser tratada como:
        // 1. Usuário desmarca 'recorrente': perguntar se quer remover futuras instâncias.
        // 2. Usuário muda dias/tipo: remover futuras e recriar.
        // Esta função placeholder pode ser expandida depois.
        async function updateRecurringInstances(task) {
            console.log("Atualização de instâncias recorrentes precisa de lógica mais detalhada.", task);
            // Implementação futura: buscar instâncias com parentTaskId, deletar e recriar ou atualizar.
            // Por ora, apenas recarregamos para refletir a mudança na tarefa pai.
            await loadTasks();
        }

        async function deleteTask(taskId) {
            const { deleteDoc, doc, collection, query, where, getDocs } = window.firebaseFirestore;
            const task = tasks.find(t => t.id === taskId);

            if (task) {
                try {
                    // Se a tarefa for recorrente e o usuário confirmar, excluir todas as instâncias
                    if (task.recurrent && confirm("Deseja excluir esta tarefa e todas as suas ocorrências futuras?")) {
                        // Excluir a tarefa principal
                        await deleteDoc(doc(window.db, "tasks", taskId));
                        // Excluir todas as instâncias futuras
                        const q = query(collection(window.db, "tasks"), where("parentTaskId", "==", taskId));
                        const querySnapshot = await getDocs(q);
                        querySnapshot.forEach(async (docSnapshot) => {
                            await deleteDoc(doc(window.db, "tasks", docSnapshot.id));
                        });
                    } else if (!task.recurrent && task.parentTaskId && confirm("Esta é uma instância de uma tarefa recorrente. Deseja excluir apenas esta instância ou a tarefa recorrente original e todas as suas instâncias? \nClique OK para excluir apenas esta instância, ou Cancelar e edite a tarefa original para modificar a recorrência.")) {
                        // Excluir apenas esta instância se não for a tarefa pai recorrente
                         await deleteDoc(doc(window.db, "tasks", taskId));
                    } else if (!task.recurrent && !task.parentTaskId) { // Tarefa normal não recorrente
                         await deleteDoc(doc(window.db, "tasks", taskId));
                    }
                     // Se for uma instância e o usuário cancelar, ou se for a tarefa pai e o usuário cancelar a exclusão das instâncias, não faz nada além de não deletar.
                } catch (error) {
                    console.error("Erro ao deletar tarefa do Firestore: ", error);
                }
                await loadTasks(); // Recarregar tarefas
            }
        }

        function confirmDeleteAllData() {
            showConfirmationModal(
                "Tem certeza que deseja excluir TODAS as tarefas? Esta ação não pode ser desfeita.",
                async () => {
                    console.log("Iniciando exclusão de todos os dados...");
                    const { deleteDoc, doc, collection, getDocs } = window.firebaseFirestore;
                    try {
                        // É mais seguro buscar todos os documentos da coleção 'tasks' e depois deletá-los
                        // do que depender apenas do array 'tasks' local, que pode não estar completo.
                        const tasksCol = collection(window.db, "tasks");
                        const taskSnapshot = await getDocs(tasksCol);

                        if (taskSnapshot.empty) {
                            console.log("Nenhuma tarefa encontrada para excluir.");
                            alert("Nenhuma tarefa para excluir.");
                            return;
                        }

                        const deletePromises = [];
                        taskSnapshot.forEach(docSnapshot => {
                            console.log(`Preparando para excluir tarefa ID: ${docSnapshot.id}`);
                            deletePromises.push(deleteDoc(doc(window.db, "tasks", docSnapshot.id)));
                        });

                        await Promise.all(deletePromises);

                        console.log("Todas as tarefas foram excluídas do Firestore.");
                        localStorage.removeItem('dataRetentionDays'); // Opcional: resetar retenção
                        updateRetentionDropdownUI(getDataRetentionDays()); // Atualizar UI
                        await loadTasks(); // Recarregar para mostrar a lista vazia
                        alert("Todos os dados foram excluídos com sucesso!");
                    } catch (error) {
                        console.error("Erro ao excluir todos os dados:", error);
                        alert("Ocorreu um erro ao tentar excluir todos os dados.");
                    }
                    hideConfirmationModal();
                },
                "Confirmar Exclusão Total"
            );
        }

        async function startTask(taskId) {
            const { updateDoc, doc, Timestamp } = window.firebaseFirestore;
            const taskDocRef = doc(window.db, "tasks", taskId);
            try {
                await updateDoc(taskDocRef, {
                    status: 'in-progress',
                    realStartTime: Timestamp.now()
                });
                await loadTasks();
            } catch (error) {
                console.error("Erro ao iniciar tarefa:", error);
            }
        }

        async function finishTask(taskId) {
            const { updateDoc, doc, Timestamp } = window.firebaseFirestore;
            const taskDocRef = doc(window.db, "tasks", taskId);
            try {
                await updateDoc(taskDocRef, {
                    status: 'completed',
                    realEndTime: Timestamp.now()
                });
                await loadTasks();
            } catch (error) {
                console.error("Erro ao finalizar tarefa:", error);
            }
        }

        /* Removida função markTaskStatus, pois os botões OK/NOK foram removidos.
        async function markTaskStatus(taskId, newStatus) { // Renomeado 'status' para 'newStatus' para evitar conflito
            const { updateDoc, doc } = window.firebaseFirestore;
            const taskDocRef = doc(window.db, "tasks", taskId);
            try {
                await updateDoc(taskDocRef, {
                    status: newStatus
                });
                await loadTasks();
            } catch (error) {
                console.error("Erro ao marcar status da tarefa:", error);
            }
        }
        */

        // Manipulação de Comentários com Firestore
        function openCommentsModal(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (task) {
                commentTaskIdInput.value = taskId;
                renderComments(task.comments || []);
                commentsModal.style.display = 'flex';
            }
        }

        function renderComments(commentsArray) { // Renomeado 'comments' para 'commentsArray'
            commentsList.innerHTML = '';
            if (!commentsArray || commentsArray.length === 0) {
                commentsList.innerHTML = '<li class="comment-item">Nenhum comentário ainda.</li>';
                return;
            }

            commentsArray.forEach(comment => {
                const commentEl = document.createElement('li');
                commentEl.className = 'comment-item';
                // Assegurar que comment.timestamp é um objeto Date antes de formatar
                const commentTime = comment.timestamp instanceof Date ? comment.timestamp : new Date(comment.timestamp);
                const timeStr = (commentTime && !isNaN(commentTime.getTime())) ? `${commentTime.getHours().toString().padStart(2, '0')}:${commentTime.getMinutes().toString().padStart(2, '0')}` : 'Data inválida';

                let commentHTML = `
                    <div class="comment-text">${comment.text}</div>
                    <div class="comment-time">${timeStr}</div>
                `;
                if (comment.image) {
                    commentHTML += `<img src="${comment.image}" class="comment-image" alt="Imagem do comentário">`;
                }
                commentEl.innerHTML = commentHTML;
                commentsList.appendChild(commentEl);
            });
        }

        async function addComment() {
            const { updateDoc, doc, Timestamp } = window.firebaseFirestore;
            const currentTaskId = commentTaskIdInput.value; // Renomeado para evitar conflito com 'tasks' global
            const text = commentTextInput.value.trim();
            const imageFile = commentImageInput.files[0];

            if (!text && !imageFile) {
                alert('Adicione um texto ou uma imagem para o comentário.');
                return;
            }

            const taskIndex = tasks.findIndex(t => t.id === currentTaskId);
            if (taskIndex === -1) {
                console.error("Tarefa não encontrada para adicionar comentário:", currentTaskId);
                return;
            }

            let taskToUpdate = { ...tasks[taskIndex] }; // Clonar a tarefa para modificação

            if (taskToUpdate.comments && taskToUpdate.comments.length >= 10) {
                alert('Limite de 10 comentários atingido para esta tarefa.');
                return;
            }

            const newComment = {
                id: Date.now().toString(), // ID local para o comentário
                text,
                timestamp: Timestamp.now() // Timestamp do Firestore para o novo comentário
            };

            const processAndSaveComment = async (commentData) => {
                if (!Array.isArray(taskToUpdate.comments)) {
                    taskToUpdate.comments = [];
                }
                taskToUpdate.comments.push(commentData);

                // Preparar apenas os comentários para atualização, convertendo Date para Timestamp se necessário
                const commentsToSave = taskToUpdate.comments.map(c => {
                    if (c.timestamp instanceof Date) { // Se algum comentário antigo ainda for Date (improvável aqui, mas seguro)
                        return {...c, timestamp: Timestamp.fromDate(c.timestamp)};
                    }
                    return c; // Já deve ser Timestamp do Firestore ou de newComment
                });

                try {
                    const taskDocRef = doc(window.db, "tasks", currentTaskId);
                    await updateDoc(taskDocRef, { comments: commentsToSave });
                    await loadTasks(); // Recarregar para refletir a mudança
                    // Reabrir modal de comentários para mostrar o novo comentário
                    openCommentsModal(currentTaskId);
                    commentTextInput.value = '';
                    commentImageInput.value = '';
                } catch (error) {
                    console.error("Erro ao adicionar comentário no Firestore:", error);
                }
            };

            if (imageFile) {
                const reader = new FileReader();
                reader.onload = async function(e) {
                    newComment.image = e.target.result; // Adicionar imagem como base64
                    await processAndSaveComment(newComment);
                };
                reader.readAsDataURL(imageFile);
            } else {
                await processAndSaveComment(newComment);
            }
        }

        // Renderização da UI (renderTasks, renderWeekView, updateStatistics permanecem majoritariamente iguais,
        // mas dependem da estrutura de 'tasks' carregada do Firestore)
        function renderTasks() {
            tasksContainer.innerHTML = '';
            const currentDateStr = formatDate(currentDate);
            // Filtrar tarefas para o dia atual. Certifique-se que task.date é um objeto Date válido.
            const dayTasks = tasks.filter(task => task.date && formatDate(task.date) === currentDateStr);

            if (dayTasks.length === 0) {
                tasksContainer.innerHTML = `
                    <div class="alert alert-info">
                        <svg class="icon alert-icon" viewBox="0 0 24 24">
                            <path d="M11 17h2v-6h-2v6zm1-15C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-11h2V6h-2v3z"></path>
                        </svg>
                        <div>Nenhuma tarefa para este dia. Adicione uma nova tarefa clicando no botão +</div>
                    </div>
                `;
                return;
            }

            dayTasks.sort((a, b) => a.startTime.localeCompare(b.startTime));

            dayTasks.forEach(task => {
                const taskEl = document.createElement('div');
                taskEl.className = `task-item priority-${task.priority}`;
                taskEl.dataset.id = task.id; // ID do Firestore

                const isTaskPast = isPast(task.date); // task.date deve ser um objeto Date
                const taskDateObject = task.date instanceof Date ? task.date : new Date(task.date); // Garantir que é Date
                const isInProgress = task.status === 'in-progress';
                const isCompleted = task.status === 'completed';
                const isNotCompleted = task.status === 'not-completed'; // Novo estado

                // Lógica de visibilidade para Editar/Deletar
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const taskDateOnly = new Date(taskDateObject);
                taskDateOnly.setHours(0,0,0,0);

                const deadline = new Date(taskDateOnly);
                deadline.setDate(taskDateOnly.getDate() - 1);

                const canEditOrDelete = today <= deadline && !isInProgress && !isCompleted && !isNotCompleted;

                let statusIcon = '';
                if (isCompleted) statusIcon = `<span class="badge badge-success">Finalizada</span>`;
                else if (isNotCompleted) statusIcon = `<span class="badge badge-warning">Não Concluída</span>`;
                else if (isInProgress) statusIcon = `<span class="badge badge-primary">Em andamento</span>`;

                let recurrentIcon = (task.recurrent || task.parentTaskId) ? `
                    <svg class="icon icon-sm" viewBox="0 0 24 24" style="margin-left: 8px; color: #6a3093;">
                        <path d="M12 6v3l4-4-4-4v3c-4.42 0-8 3.58-8 8 0 1.57.46 3.03 1.24 4.26L6.7 14.8c-.45-.83-.7-1.79-.7-2.8 0-3.31 2.69-6 6-6zm6.76 1.74L17.3 9.2c.44.84.7 1.79.7 2.8 0 3.31-2.69 6-6 6v-3l-4 4 4 4v-3c4.42 0 8-3.58 8-8 0-1.57-.46-3.03-1.24-4.26z"></path>
                    </svg>` : '';

                let commentsIndicator = (task.comments && task.comments.length > 0) ? `
                    <span class="badge badge-primary" style="margin-left: 8px;">
                        <svg class="icon icon-sm" viewBox="0 0 24 24" style="margin-right: 2px;">
                            <path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"></path>
                        </svg> ${task.comments.length}
                    </span>` : '';

                let realTimeInfo = '';
                if (task.realStartTime && task.realEndTime) {
                    const realStart = task.realStartTime instanceof Date ? task.realStartTime : new Date(task.realStartTime);
                    const realEnd = task.realEndTime instanceof Date ? task.realEndTime : new Date(task.realEndTime);
                    if (!isNaN(realStart.getTime()) && !isNaN(realEnd.getTime())) {
                         realTimeInfo = `
                            <div class="real-time-info" style="font-size: 0.8rem; color: #666; margin-top: 5px;">
                                <svg class="icon icon-sm" viewBox="0 0 24 24" style="vertical-align: middle; margin-right: 2px;">
                                    <path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z"></path>
                                </svg>
                                Executado: ${formatTime(realStart.toTimeString())} - ${formatTime(realEnd.toTimeString())}
                            </div>`;
                    }
                }

                taskEl.innerHTML = `
                    <div class="task-header">
                        <div class="task-time">${formatTime(task.startTime)} - ${formatTime(task.endTime)}</div>
                        <h3 class="task-title">${task.title} ${recurrentIcon}</h3>
                        ${statusIcon} ${commentsIndicator}
                    </div>
                    ${task.description ? `<div class="task-description">${task.description}</div>` : ''}
                    ${realTimeInfo}
                    <div class="task-actions">
                        <div class="task-action-buttons">
                            ${!isTaskPast && !isCompleted && !isNotCompleted ? `
                                ${!isInProgress ? `<button class="btn btn-secondary btn-sm start-task-btn"><svg class="icon icon-sm btn-icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"></path></svg>Iniciar</button>` : ''}
                                ${isInProgress ? `
                                    <button class="btn btn-success btn-sm finish-task-btn"><svg class="icon icon-sm btn-icon" viewBox="0 0 24 24"><path d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z"></path></svg>Finalizar</button>
                                    <button class="btn btn-warning btn-sm not-completed-task-btn" style="margin-left: 5px;"><svg class="icon icon-sm btn-icon" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-5h2v2h-2v-2zm0-8h2v6h-2V7z"/></svg>Não Concluído</button>
                                ` : ''}
                            ` : ''}
                            <button class="btn btn-secondary btn-sm comments-btn"><svg class="icon icon-sm btn-icon" viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"></path></svg>Comentários</button>
                        </div>
                        <div class="task-management">
                            ${canEditOrDelete ? `
                                <button class="btn btn-secondary btn-sm edit-task-btn"><svg class="icon icon-sm" viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"></path></svg></button>
                                <button class="btn btn-danger btn-sm delete-task-btn"><svg class="icon icon-sm" viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path></svg></button>
                            ` : ''}
                            ${'' /* Removido: ${isCompleted ? `<div class="task-status-buttons"><button class="btn btn-success btn-sm task-ok-btn">OK</button><button class="btn btn-danger btn-sm task-nok-btn">NOK</button></div>` : ''} */}
                        </div>
                    </div>
                `;

                taskEl.querySelector('.comments-btn')?.addEventListener('click', () => openCommentsModal(task.id));
                taskEl.querySelector('.start-task-btn')?.addEventListener('click', () => startTask(task.id));
                taskEl.querySelector('.finish-task-btn')?.addEventListener('click', () => finishTask(task.id));
                taskEl.querySelector('.not-completed-task-btn')?.addEventListener('click', () => markTaskNotCompleted(task.id));
                taskEl.querySelector('.edit-task-btn')?.addEventListener('click', () => openTaskModal(task.id));
                taskEl.querySelector('.delete-task-btn')?.addEventListener('click', () => deleteTask(task.id));

                tasksContainer.appendChild(taskEl);
            });
        }

        async function markTaskNotCompleted(taskId) {
            const { updateDoc, doc, Timestamp } = window.firebaseFirestore;
            const taskDocRef = doc(window.db, "tasks", taskId);
            try {
                await updateDoc(taskDocRef, {
                    status: 'not-completed', // Novo status
                    realEndTime: Timestamp.now() // Também registra o tempo de finalização
                });
                await loadTasks(); // Recarrega as tarefas
            } catch (error) {
                console.error("Erro ao marcar tarefa como não concluída:", error);
            }
        }

        function renderWeekView() {
            const viewMode = getWeekViewMode();
            weekViewContainer.innerHTML = '';
            // Clear previous classes like 'week-view-horizontal'
            weekViewContainer.className = 'week-view'; // Reset to default class

            // currentDate já deve ser a Segunda-feira da semana a ser exibida (ajustado pelos botões prev/next)
            // ou o dia atual na primeira carga se a aba semana for selecionada.
            // Precisamos garantir que firstDayOfWeekComputed seja sempre uma segunda-feira.
            let firstDayOfWeekComputed = new Date(currentDate);
            const dayOfWeek = firstDayOfWeekComputed.getDay(); // 0 (Dom) a 6 (Sáb)
            const diffToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
            firstDayOfWeekComputed.setDate(firstDayOfWeekComputed.getDate() + diffToMonday);

            if (viewMode === 'horizontal') {
                renderWeekViewHorizontal(firstDayOfWeekComputed);
            } else {
                renderWeekViewVertical(firstDayOfWeekComputed);
            }
        }

        function renderWeekViewVertical(firstDayOfWeekDate) {
             // Lógica existente da renderWeekView, agora em sua própria função
            document.body.classList.remove('week-horizontal-view-active'); // Remover classe do body
            weekViewContainer.classList.remove('week-view-horizontal');
            weekViewContainer.style.display = 'grid';
            // Resetar estilos de largura/margem que podem ter sido aplicados pela visualização horizontal
            weekViewContainer.style.marginLeft = '';
            weekViewContainer.style.marginRight = '';
            weekViewContainer.style.paddingLeft = '';
            weekViewContainer.style.paddingRight = '';
            weekViewContainer.style.width = '';
            weekViewContainer.style.maxWidth = '';


            for (let i = 0; i < 7; i++) {
                const date = new Date(firstDayOfWeekDate);
                date.setDate(firstDayOfWeekDate.getDate() + i);
                const dateStr = formatDate(date);
                // isCurrentDateView pode precisar ser reavaliado ou removido se currentDate é sempre Seg.
                const isCurrentDateView = date.getDate() === currentDate.getDate() && date.getMonth() === currentDate.getMonth() && date.getFullYear() === currentDate.getFullYear();


                const dayTasks = tasks.filter(task => task.date && formatDate(task.date) === dateStr);
                dayTasks.sort((a, b) => a.startTime.localeCompare(b.startTime));

                const dayEl = document.createElement('div');
                dayEl.className = 'week-day'; // Classe padrão para os dias na visualização vertical
                 if (isCurrentDateView && getWeekViewMode() === 'vertical') { // Só destacar se for a visualização vertical
                    dayEl.style.borderColor = '#6a3093';
                    dayEl.style.borderWidth = '2px';
                }


                dayEl.innerHTML = `
                    <div class="week-day-header">
                        <div class="day-name">${shortDayNames[date.getDay()]}</div>
                        <div class="day-date">${date.getDate()}/${date.getMonth() + 1}</div>
                    </div>
                    <div class="day-tasks">
                        ${dayTasks.length === 0 ? '<div class="week-task" style="color: #999; text-align: center;">Sem tarefas</div>' :
                        dayTasks.map(task => `
                            <div class="week-task priority-${task.priority}" data-task-id="${task.id}">
                                <div class="week-task-time">${formatTime(task.startTime)}</div>
                                <div class="week-task-title">${task.title}</div>
                            </div>
                        `).join('')}
                    </div>
                `;

                dayEl.querySelectorAll('.week-task').forEach(taskEl => {
                    taskEl.addEventListener('click', () => {
                        currentDate = new Date(date); // Navegar para o dia clicado
                        updateDateDisplay();
                        renderTasks();
                        document.querySelector('.nav-tab[data-tab="agenda"]').click(); // Mudar para aba Agenda
                    });
                });
                weekViewContainer.appendChild(dayEl);
            }
        }

        function renderWeekViewHorizontal(firstDayOfWeekDate) {
            // Implementação da visualização horizontal (Estilo Planner)
            document.body.classList.add('week-horizontal-view-active'); // Adicionar classe ao body
            weekViewContainer.classList.add('week-view-horizontal');
            weekViewContainer.style.display = 'block';
            weekViewContainer.innerHTML = ''; // Limpar conteúdo anterior

            const table = document.createElement('table');
            const thead = document.createElement('thead');
            const tbody = document.createElement('tbody');

            // 1. Criar Cabeçalho da Tabela (Horários)
            const headerRow = document.createElement('tr');
            const firstHeaderCell = document.createElement('th');
            firstHeaderCell.textContent = 'Dia'; // Ou pode ser vazio
            headerRow.appendChild(firstHeaderCell);

            for (let hour = HORIZONTAL_VIEW_START_HOUR; hour < HORIZONTAL_VIEW_END_HOUR; hour++) {
                const th = document.createElement('th');
                th.textContent = `${hour.toString().padStart(2, '0')}:00`;
                headerRow.appendChild(th);
            }
            thead.appendChild(headerRow);
            table.appendChild(thead);

            // 2. Criar Linhas para Cada Dia da Semana
            for (let i = 0; i < 7; i++) {
                const dayDate = new Date(firstDayOfWeekDate);
                dayDate.setDate(firstDayOfWeekDate.getDate() + i);

                const dayRow = document.createElement('tr');

                // Célula do Dia (Nome e Data)
                const dayInfoCell = document.createElement('td');
                dayInfoCell.className = 'day-info-cell';
                // Dia e data lado a lado
                dayInfoCell.innerHTML = `${shortDayNames[dayDate.getDay()]} ${dayDate.getDate()}/${dayDate.getMonth() + 1}`;
                dayRow.appendChild(dayInfoCell);

                // Células de Horário para esta linha do dia (onde as tarefas serão colocadas)
                // Estas células servirão de base, mas as tarefas serão posicionadas absolutamente sobre uma área que representa o dia inteiro.
                // Para simplificar a estrutura inicial, vamos criar um container para as tarefas do dia que abrange todas as horas.
                const tasksContainerCell = document.createElement('td');
                tasksContainerCell.colSpan = HOUR_COLUMN_COUNT; // Faz esta célula ocupar todas as colunas de horário
                tasksContainerCell.style.position = 'relative'; // Para posicionamento absoluto dos blocos de tarefa
                tasksContainerCell.dataset.dayDateStr = formatDate(dayDate); // Para identificar a célula depois

                // Adicionar sub-células visuais para as horas (opcional, para linhas de grade)
                // Ou deixar que os blocos de tarefa definam a grade visualmente.

                // Renderizar tarefas para este dia
                const dayTasks = tasks.filter(t => t.date && formatDate(t.date) === formatDate(dayDate));
                dayTasks.sort((a, b) => a.startTime.localeCompare(b.startTime));

                // Com a validação de não sobreposição, todas as tarefas ficam na mesma "pista" horizontal.
                const fixedTopPosition = "2px"; // Posição vertical fixa para os blocos de tarefa.

                dayTasks.forEach(task => {
                    const taskBlock = document.createElement('div');
                    taskBlock.className = `task-block priority-${task.priority}`;
                    taskBlock.textContent = `${formatTime(task.startTime)} ${task.title}`;
                    taskBlock.title = `${task.title} (${formatTime(task.startTime)} - ${formatTime(task.endTime)})`;

                    const styleProps = getTaskBlockStyle(task);

                    taskBlock.style.left = styleProps.left;
                    taskBlock.style.width = styleProps.width;
                    taskBlock.style.display = styleProps.display;
                    taskBlock.style.top = fixedTopPosition;

                    taskBlock.addEventListener('click', () => {
                        currentDate = new Date(dayDate);
                        updateDateDisplay();
                        renderTasks();
                        document.querySelector('.nav-tab[data-tab="agenda"]').click();
                    });

                    tasksContainerCell.appendChild(taskBlock);
                });


                dayRow.appendChild(tasksContainerCell);
                tbody.appendChild(dayRow);
            }

            table.appendChild(tbody);
            weekViewContainer.appendChild(table);
        }

        function getTaskBlockStyle(task) { // Removido dayTasksContainerWidth
            const taskStart = new Date(`2000-01-01T${task.startTime}`);
            const taskEnd = new Date(`2000-01-01T${task.endTime}`);

            const gridStartTime = new Date(`2000-01-01T${HORIZONTAL_VIEW_START_HOUR.toString().padStart(2, '0')}:00`);
            const gridEndTime = new Date(`2000-01-01T${HORIZONTAL_VIEW_END_HOUR.toString().padStart(2, '0')}:00`);

            // Converter para minutos desde o início do dia para facilitar o cálculo
            const taskStartMinutes = taskStart.getHours() * 60 + taskStart.getMinutes();
            const taskEndMinutes = taskEnd.getHours() * 60 + taskEnd.getMinutes();
            const gridStartMinutes = gridStartTime.getHours() * 60 + gridStartTime.getMinutes();
            const gridEndMinutes = gridEndTime.getHours() * 60 + gridEndTime.getMinutes();

            const totalGridMinutes = gridEndMinutes - gridStartMinutes;
            if (totalGridMinutes <= 0) return { left: '0px', width: '0px', display: 'none' }; // Evitar divisão por zero

            // Calcular o início e o fim da tarefa, limitados pela grade visível
            const effectiveStartMinutes = Math.max(taskStartMinutes, gridStartMinutes);
            const effectiveEndMinutes = Math.min(taskEndMinutes, gridEndMinutes);

            if (effectiveStartMinutes >= effectiveEndMinutes) { // Tarefa fora da grade visível
                return { left: '0px', width: '0px', display: 'none' };
            }

            const leftOffsetMinutes = effectiveStartMinutes - gridStartMinutes;
            const durationMinutesInGrid = effectiveEndMinutes - effectiveStartMinutes;

            const leftPercentage = (leftOffsetMinutes / totalGridMinutes) * 100;
            const widthPercentage = (durationMinutesInGrid / totalGridMinutes) * 100;

            // Usar porcentagens para left e width em relação ao tasksContainerCell
            return {
                left: `${leftPercentage}%`,
                width: `${widthPercentage}%`,
                display: 'block' // Garantir que seja visível
            };
        }


        function updateStatistics() {
            const today = new Date();
            const startOfWeek = new Date(today);
            startOfWeek.setDate(today.getDate() - today.getDay());
            startOfWeek.setHours(0, 0, 0, 0);
            const endOfWeek = new Date(startOfWeek);
            endOfWeek.setDate(startOfWeek.getDate() + 6);
            endOfWeek.setHours(23, 59, 59, 999);

            const weekTasks = tasks.filter(task => {
                if (!task.date) return false;
                const taskDate = task.date instanceof Date ? task.date : new Date(task.date);
                return taskDate >= startOfWeek && taskDate <= endOfWeek;
            });

            const totalWeekTasks = weekTasks.length;
            const completedWeekTasks = weekTasks.filter(t => t.status === 'completed' || t.status === 'ok' || t.status === 'nok').length;

            tasksCompletedEl.textContent = completedWeekTasks;
            tasksCompletedRatioEl.textContent = `concluídas de ${totalWeekTasks} tarefas`;

            const tasksWithRealTime = weekTasks.filter(t => t.realStartTime && t.realEndTime);
            let onTimeTasksCount = 0; // Renomeado para evitar conflito
            tasksWithRealTime.forEach(task => {
                const plannedStart = new Date(`${formatDate(task.date)}T${task.startTime}`);
                const realStart = task.realStartTime instanceof Date ? task.realStartTime : new Date(task.realStartTime);
                if (!isNaN(plannedStart.getTime()) && !isNaN(realStart.getTime())) {
                    if (realStart <= plannedStart) onTimeTasksCount++; // Simplificado: considera pontual se começou no horário ou antes
                }
            });
            tasksOnTimeEl.textContent = onTimeTasksCount;
            tasksOnTimeRatioEl.textContent = `no horário de ${tasksWithRealTime.length} executadas`;

            const priorityCounts = weekTasks.reduce((acc, task) => {
                acc[task.priority] = (acc[task.priority] || 0) + 1;
                return acc;
            }, { critical: 0, attention: 0, normal: 0 });

            priorityCriticalPercentEl.textContent = totalWeekTasks > 0 ? `${Math.round((priorityCounts.critical / totalWeekTasks) * 100)}%` : '0%';
            priorityAttentionPercentEl.textContent = totalWeekTasks > 0 ? `${Math.round((priorityCounts.attention / totalWeekTasks) * 100)}%` : '0%';
            priorityNormalPercentEl.textContent = totalWeekTasks > 0 ? `${Math.round((priorityCounts.normal / totalWeekTasks) * 100)}%` : '0%';
        }
    </script>

    <script type="module">
      // Import the functions you need from the SDKs you need
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-app.js";
      import { getFirestore, collection, addDoc, getDocs, doc, updateDoc, deleteDoc, onSnapshot, query, where, Timestamp } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-firestore.js";

      // Your web app's Firebase configuration
      const firebaseConfig = {
        apiKey: "AIzaSyBIsl6nEhaByJbdz4Jg0MDdImPgTygim2Q",
        authDomain: "agenda-diaria-ada7f.firebaseapp.com",
        projectId: "agenda-diaria-ada7f",
        storageBucket: "agenda-diaria-ada7f.firebasestorage.app",
        messagingSenderId: "221405263450",
        appId: "1:221405263450:web:7e1b21df7fef5ef60dca63"
      };

      // Initialize Firebase
      const app = initializeApp(firebaseConfig);
      const db = getFirestore(app);

      // Make db and firestore functions globally available for the existing script
      window.db = db;
      window.firebaseFirestore = {
          collection, addDoc, getDocs, doc, updateDoc, deleteDoc, onSnapshot, query, where, Timestamp
      };
    </script>
</body>
</html>
